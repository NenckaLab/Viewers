import { useState, useEffect } from 'react';
import debounce from 'lodash.debounce';
import { useSystem } from '@ohif/core';

function mapMeasurementToDisplay(measurement, displaySetService) {
  const { referenceSeriesUID } = measurement;

  console.log(`🔍 DEBUG: useMeasurements mapMeasurementToDisplay called for measurement ${measurement.uid}`);
  console.log(`🔍 DEBUG: referenceSeriesUID: ${referenceSeriesUID}`);
  console.log(`🔍 DEBUG: measurement.displayText:`, measurement.displayText);
  console.log(`🔍 DEBUG: measurement.label:`, measurement.label);

  const displaySets = displaySetService.getDisplaySetsForSeries(referenceSeriesUID);
  console.log(`🔍 DEBUG: displaySets found:`, displaySets);

  if (!displaySets[0]?.instances && !displaySets[0]?.images) {
    console.error(`🔍 DEBUG: No instances or images found in displaySets[0]:`, displaySets[0]);
    throw new Error('The tracked measurements panel should only be tracking "stack" displaySets.');
  }

  console.log(`🔍 DEBUG: displaySets[0] has instances:`, !!displaySets[0]?.instances);
  console.log(`🔍 DEBUG: displaySets[0] has images:`, !!displaySets[0]?.images);

  const { findingSites, finding, label: baseLabel, displayText: baseDisplayText } = measurement;

  console.log(`🔍 DEBUG: baseDisplayText extracted:`, baseDisplayText);
  console.log(`🔍 DEBUG: baseLabel extracted:`, baseLabel);

  const firstSite = findingSites?.[0];
  const label = baseLabel || finding?.text || firstSite?.text || '(empty)';

  // Initialize displayText with the structure used in Length.ts and CobbAngle.ts
  const displayText = {
    primary: [],
    secondary: baseDisplayText?.secondary || [],
  };

  console.log(`🔍 DEBUG: initial displayText:`, displayText);

  // Add baseDisplayText to primary if it exists
  if (baseDisplayText && baseDisplayText.primary) {
    console.log(`🔍 DEBUG: adding baseDisplayText.primary to displayText:`, baseDisplayText.primary);
    displayText.primary.push(...baseDisplayText.primary);
  } else {
    console.log(`🔍 DEBUG: baseDisplayText.primary not found or empty:`, baseDisplayText);
  }

  // Add finding sites to primary
  if (findingSites) {
    findingSites.forEach(site => {
      if (site?.text && site.text !== label) {
        displayText.primary.push(site.text);
      }
    });
  }

  // Add finding to primary if it's different from the label
  if (finding && finding.text && finding.text !== label) {
    displayText.primary.push(finding.text);
  }

  const result = {
    ...measurement,
    displayText,
    label,
  };

  console.log(`🔍 DEBUG: mapMeasurementToDisplay returning for ${measurement.uid}:`, result);
  return result;
}

/**
 * A custom hook that provides mapped measurements based on the given services and filters.
 *
 * @param {Object} servicesManager - The services manager object.
 * @param {Object} options - The options for filtering and mapping measurements.
 * @param {Function} options.measurementFilter - Optional function to filter measurements.
 * @param {Object} options.valueTypes - The value types for mapping measurements.
 * @returns {Array} An array of mapped and filtered measurements.
 */
export function useMeasurements({ measurementFilter } = { measurementFilter: () => true }) {
  const { servicesManager } = useSystem();
  const { measurementService, displaySetService } = servicesManager.services;
  const [displayMeasurements, setDisplayMeasurements] = useState([]);

  useEffect(() => {
    const updateDisplayMeasurements = () => {
      const measurements = measurementService.getMeasurements(measurementFilter);
      const mappedMeasurements = measurements.map(m =>
        mapMeasurementToDisplay(m, displaySetService)
      );
      setDisplayMeasurements(prevMeasurements => {
        if (JSON.stringify(prevMeasurements) !== JSON.stringify(mappedMeasurements)) {
          return mappedMeasurements;
        }
        return prevMeasurements;
      });
    };

    const debouncedUpdate = debounce(updateDisplayMeasurements, 100);

    updateDisplayMeasurements();

    const events = [
      measurementService.EVENTS.MEASUREMENT_ADDED,
      measurementService.EVENTS.RAW_MEASUREMENT_ADDED,
      measurementService.EVENTS.MEASUREMENT_UPDATED,
      measurementService.EVENTS.MEASUREMENT_REMOVED,
      measurementService.EVENTS.MEASUREMENTS_CLEARED,
    ];

    const subscriptions = events.map(
      evt => measurementService.subscribe(evt, debouncedUpdate).unsubscribe
    );

    return () => {
      subscriptions.forEach(unsub => unsub());
      debouncedUpdate.cancel();
    };
  }, [measurementService, measurementFilter, displaySetService]);

  return displayMeasurements;
} 